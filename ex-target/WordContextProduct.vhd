-- File: ./ex-target/WordContextProduct.vhd
-- Generated by MyHDL 1.0dev
-- Date: Mon Oct  5 14:11:53 2015


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_10.all;

entity WordContextProduct is
    port (
        y: out signed (15 downto 0);
        y_dword_vec: out unsigned(47 downto 0);
        y_dcontext_vec: out unsigned(47 downto 0);
        word_embv: inout unsigned(47 downto 0);
        context_embv: inout unsigned(47 downto 0)
    );
end entity WordContextProduct;
-- Word-context embeddings product and derivative model.
-- 
-- :param y: return relu(dot(word_emb, context_emb)) as fixbv
-- :param y_dword_vec: return d/dword relu(dot(word_emb, context_emb)) as vector of fixbv
-- :param y_dcontext_vec: return d/dcontext relu(dot(word_emb, context_emb)) as vector of fixbv
-- :param word_embv: word embedding vector of fixbv
-- :param context_embv: context embedding vector of fixbv
-- :param embedding_dim: embedding dimensionality
-- :param leaky_val: factor for leaky ReLU, 0.0 without
-- :param fix_min: fixbv min value
-- :param fix_max: fixbv max value
-- :param fix_res: fixbv resolution

architecture MyHDL of WordContextProduct is



signal y_dot_dword_vec: unsigned(47 downto 0);
signal y_dot: signed (15 downto 0);
signal y_relu_dx: signed (15 downto 0);
signal y_dot_dcontext_vec: unsigned(47 downto 0);
type t_array_y_dot_dword_list is array(0 to 3-1) of signed (15 downto 0);
signal y_dot_dword_list: t_array_y_dot_dword_list;
type t_array_y_dot_dcontext_list is array(0 to 3-1) of signed (15 downto 0);
signal y_dot_dcontext_list: t_array_y_dot_dcontext_list;
type t_array_dot_a_list is array(0 to 3-1) of signed (15 downto 0);
signal dot_a_list: t_array_dot_a_list;
type t_array_dot_b_list is array(0 to 3-1) of signed (15 downto 0);
signal dot_b_list: t_array_dot_b_list;

begin



context_embv(48-1 downto 32) <= None;
context_embv(32-1 downto 16) <= None;
context_embv(16-1 downto 0) <= None;
word_embv(48-1 downto 32) <= None;
word_embv(32-1 downto 16) <= None;
word_embv(16-1 downto 0) <= None;
y_dot_dword_list(0) <= y_dot_dword_vec(16-1 downto 0);
y_dot_dword_list(1) <= y_dot_dword_vec(32-1 downto 16);
y_dot_dword_list(2) <= y_dot_dword_vec(48-1 downto 32);
y_dot_dcontext_list(0) <= y_dot_dcontext_vec(16-1 downto 0);
y_dot_dcontext_list(1) <= y_dot_dcontext_vec(32-1 downto 16);
y_dot_dcontext_list(2) <= y_dot_dcontext_vec(48-1 downto 32);
dot_a_list(0) <= word_embv(16-1 downto 0);
dot_a_list(1) <= word_embv(32-1 downto 16);
dot_a_list(2) <= word_embv(48-1 downto 32);
dot_b_list(0) <= context_embv(16-1 downto 0);
dot_b_list(1) <= context_embv(32-1 downto 16);
dot_b_list(2) <= context_embv(48-1 downto 32);


WORDCONTEXTPRODUCT_DOT_DOT: process (dot_a_list, dot_b_list) is
    variable y_sum: signed(31 downto 0);
begin
    y_sum := to_signed(0.0, 32);
    for j in 0 to 3-1 loop
        y_sum := (y_sum + (dot_a_list(j) * dot_b_list(j)));
    end loop;
    y_dot <= to_signed(y_sum, 16);
end process WORDCONTEXTPRODUCT_DOT_DOT;



y_dot_dword_vec <= context_embv;



y_dot_dcontext_vec <= word_embv;


WORDCONTEXTPRODUCT_RELU_RELU: process (y_dot) is
    variable zero: signed(15 downto 0);
    variable leaky: signed(15 downto 0);
begin
    if (y_dot > zero) then
        y <= y_dot;
    else
        y <= to_signed((leaky * y_dot), 16);
    end if;
end process WORDCONTEXTPRODUCT_RELU_RELU;


WORDCONTEXTPRODUCT_RELU_RELU_DX: process (y_dot) is
    variable zero: signed(15 downto 0);
    variable leaky: signed(15 downto 0);
    variable one: signed(15 downto 0);
begin
    if (y_dot > zero) then
        y_relu_dx <= one;
    else
        y_relu_dx <= leaky;
    end if;
end process WORDCONTEXTPRODUCT_RELU_RELU_DX;


WORDCONTEXTPRODUCT_WCPROD_DWORD: process (y_relu_dx, y_dot_dword_list) is
    variable prod: signed(15 downto 0);
begin
    for j in 0 to 3-1 loop
        prod := to_signed((y_relu_dx * y_dot_dword_list(j)), 16);
        y_dword_vec(((j + 1) * 16)-1 downto (j * 16)) <= unsigned(prod);
    end loop;
end process WORDCONTEXTPRODUCT_WCPROD_DWORD;


WORDCONTEXTPRODUCT_WCPROD_DCONTEXT: process (y_relu_dx, y_dot_dcontext_list) is
    variable prod: signed(15 downto 0);
begin
    for j in 0 to 3-1 loop
        prod := to_signed((y_relu_dx * y_dot_dcontext_list(j)), 16);
        y_dcontext_vec(((j + 1) * 16)-1 downto (j * 16)) <= unsigned(prod);
    end loop;
end process WORDCONTEXTPRODUCT_WCPROD_DCONTEXT;

end architecture MyHDL;
