// File: ./ex-target/WordContextUpdated.v
// Generated by MyHDL 1.0dev
// Date: Mon Oct  5 14:15:05 2015


`timescale 1ns/10ps

module WordContextUpdated (
    y,
    error,
    new_word_embv,
    new_context_embv,
    y_actual,
    word_embv,
    context_embv
);
// Word-context embeddings updated model.
// 
// :param y: return relu(dot(word_emb, context_emb)) as fixbv
// :param error: return MSE prediction error as fixbv
// :param new_word_embv: return updated word embedding vector of fixbv
// :param new_context_embv: return updated context embedding vector of fixbv
// :param y_actual: actual training value as fixbv
// :param word_embv: word embedding vector of fixbv
// :param context_embv: context embedding vector of fixbv
// :param embedding_dim: embedding dimensionality
// :param leaky_val: factor for leaky ReLU, 0.0 without
// :param rate_val: learning rate factor
// :param fix_min: fixbv min value
// :param fix_max: fixbv max value
// :param fix_res: fixbv resolution

output signed [15:0] y;
reg signed [15:0] y;
output signed [15:0] error;
reg signed [15:0] error;
output [47:0] new_word_embv;
reg [47:0] new_word_embv;
output [47:0] new_context_embv;
reg [47:0] new_context_embv;
input signed [15:0] y_actual;
output [47:0] word_embv;
wire [47:0] word_embv;
output [47:0] context_embv;
wire [47:0] context_embv;

reg [47:0] y_dcontext_vec;
reg [47:0] y_dword_vec;
wire [47:0] wcprod_y_dot_dword_vec;
reg signed [15:0] wcprod_y_dot;
reg signed [15:0] wcprod_y_relu_dx;
wire [47:0] wcprod_y_dot_dcontext_vec;

wire signed [15:0] y_dcontext_list [0:3-1];
wire signed [15:0] context_emb [0:3-1];
wire signed [15:0] word_emb [0:3-1];
wire signed [15:0] y_dword_list [0:3-1];
wire signed [15:0] wcprod_y_dot_dword_list [0:3-1];
wire signed [15:0] wcprod_y_dot_dcontext_list [0:3-1];
wire signed [15:0] wcprod_dot_a_list [0:3-1];
wire signed [15:0] wcprod_dot_b_list [0:3-1];


assign context_embv[48-1:32] = None;
assign context_embv[32-1:16] = None;
assign context_embv[16-1:0] = None;
assign word_embv[48-1:32] = None;
assign word_embv[32-1:16] = None;
assign word_embv[16-1:0] = None;


always @(wcprod_dot_a_list[0], wcprod_dot_a_list[1], wcprod_dot_a_list[2], wcprod_dot_b_list[0], wcprod_dot_b_list[1], wcprod_dot_b_list[2]) begin: WORDCONTEXTUPDATED_WCPROD_DOT_DOT
    reg signed [32-1:0] y_sum;
    integer j;
    y_sum = fixbv(0.0);
    for (j=0; j<3; j=j+1) begin
        y_sum = (y_sum + (wcprod_dot_a_list[j] * wcprod_dot_b_list[j]));
    end
    wcprod_y_dot = fixbv(y_sum);
end



assign wcprod_y_dot_dword_vec = context_embv;



assign wcprod_y_dot_dcontext_vec = word_embv;


always @(wcprod_y_dot) begin: WORDCONTEXTUPDATED_WCPROD_RELU_RELU
    reg signed [16-1:0] zero;
    reg signed [16-1:0] leaky;
    if ((wcprod_y_dot > zero)) begin
        y = wcprod_y_dot;
    end
    else begin
        y = fixbv((leaky * wcprod_y_dot));
    end
end


always @(wcprod_y_dot) begin: WORDCONTEXTUPDATED_WCPROD_RELU_RELU_DX
    reg signed [16-1:0] zero;
    reg signed [16-1:0] leaky;
    reg signed [16-1:0] one;
    if ((wcprod_y_dot > zero)) begin
        wcprod_y_relu_dx = one;
    end
    else begin
        wcprod_y_relu_dx = leaky;
    end
end


always @(wcprod_y_relu_dx, wcprod_y_dot_dword_list[0], wcprod_y_dot_dword_list[1], wcprod_y_dot_dword_list[2]) begin: WORDCONTEXTUPDATED_WCPROD_WCPROD_DWORD
    integer j;
    reg signed [16-1:0] prod;
    for (j=0; j<3; j=j+1) begin
        prod = fixbv((wcprod_y_relu_dx * wcprod_y_dot_dword_list[j]));
        y_dword_vec[((j + 1) * 16)-1:(j * 16)] = prod;
    end
end


always @(wcprod_y_relu_dx, wcprod_y_dot_dcontext_list[0], wcprod_y_dot_dcontext_list[1], wcprod_y_dot_dcontext_list[2]) begin: WORDCONTEXTUPDATED_WCPROD_WCPROD_DCONTEXT
    integer j;
    reg signed [16-1:0] prod;
    for (j=0; j<3; j=j+1) begin
        prod = fixbv((wcprod_y_relu_dx * wcprod_y_dot_dcontext_list[j]));
        y_dcontext_vec[((j + 1) * 16)-1:(j * 16)] = prod;
    end
end


always @(y, y_actual) begin: WORDCONTEXTUPDATED_MSE
    reg signed [16-1:0] diff;
    diff = fixbv((y - y_actual));
    error = fixbv((diff * diff));
end


always @(y, word_emb[0], word_emb[1], word_emb[2], y_actual, y_dword_list[0], y_dword_list[1], y_dword_list[2]) begin: WORDCONTEXTUPDATED_UPDATED_WORD
    integer j;
    reg signed [16-1:0] new;
    reg signed [16-1:0] y_dword;
    reg signed [16-1:0] rate;
    reg signed [16-1:0] delta;
    reg signed [16-1:0] diff;
    diff = fixbv((y - y_actual));
    for (j=0; j<3; j=j+1) begin
        y_dword = fixbv(y_dword_list[j]);
        delta = fixbv(((rate * diff) * y_dword));
        new = fixbv((word_emb[j] - delta));
        new_word_embv[((j + 1) * 16)-1:(j * 16)] = new;
    end
end


always @(y, y_dcontext_list[0], y_dcontext_list[1], y_dcontext_list[2], y_actual, context_emb[0], context_emb[1], context_emb[2]) begin: WORDCONTEXTUPDATED_UPDATED_CONTEXT
    reg signed [16-1:0] y_dcontext;
    integer j;
    reg signed [16-1:0] rate;
    reg signed [16-1:0] new;
    reg signed [16-1:0] delta;
    reg signed [16-1:0] diff;
    diff = fixbv((y - y_actual));
    for (j=0; j<3; j=j+1) begin
        y_dcontext = fixbv(y_dcontext_list[j]);
        delta = fixbv(((rate * diff) * y_dcontext));
        new = fixbv((context_emb[j] - delta));
        new_context_embv[((j + 1) * 16)-1:(j * 16)] = new;
    end
end

endmodule
